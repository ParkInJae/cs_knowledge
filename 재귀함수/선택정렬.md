<ol>
<li> 선택정렬이란? </li>
<li> 선택정렬의 비재귀버전 (반복문 사용)</li>
<li> 선택정렬의 재귀버전 </li>
</ol>


<h1>선택 정렬이란?</h1>

1) 선택 정렬이란 제자리 정렬 알고리즘, 입력배열(정렬되지 않은 값들)이외에 다른 추가 메모리를 요구하지 않는 정렬 방법

2) 해당 순서에 원소를 넣을 위치는 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다.

예시 :: 최소값을 찾는 과정 
1. 주어진 배열 중에서 최솟값을 찾음 
2. 그 값을 맨 앞에 위치한 값과 교체 
3. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체 
4. 하나의 원소가 남을 때까지 위의 1~3까지의 과정을 반복함 

![alt text](images/image-4.png)


<h1>선택정렬의 비재귀버전 (반복문 사용)</h1>

```

for (int i = 0; i < n - 1; i++) {
    int minIdx = i; // 현재 위치를 최소값 인덱스로 가정
    for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[minIdx]) {
            minIdx = j; // 더 작은 값 발견 → 최소 인덱스 갱신
        }
    }
    swap(arr[i], arr[minIdx]); // 현재 위치와 최소값 위치 교환
}
```

원리
1. 바깥 반복문 i는 정렬된 부분과 미정렬 부분을 나누는 역할.

2. 안쪽 반복문 j는 미정렬 구간에서 가장 작은 값의 인덱스를 찾음.

3. minIdx는 매번 i로 초기화하여 현재 위치에서 시작.

4. 모든 요소를 순차적으로 비교하며 정렬이 끝날 때까지 진행.


<h1>선택정렬의 재귀버전 </h1>

```
void selectionSortRecursive(int arr[], int start, int n) {
    if (start >= n - 1) return; // 종료 조건

    int minIdx = start;
    for (int i = start + 1; i < n; i++) {
        if (arr[i] < arr[minIdx]) {
            minIdx = i; // 더 작은 값 발견
        }
    }
    swap(arr[start], arr[minIdx]); // 현재 위치와 최소값 위치 교환

    selectionSortRecursive(arr, start + 1, n); // 다음 구간 정렬
}

```


원리

1. start가 현재 정렬을 시작할 위치.

2. minIdx를 start로 초기화한 후, 남은 구간에서 최소값을 찾음.

3. 최소값과 start 위치를 교환한 뒤,
**남은 구간(start+1 ~ 끝)**에 대해 같은 과정을 재귀 호출.

4. 종료 조건(start >= n-1)이 되면 정렬 완료.
