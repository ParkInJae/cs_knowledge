<h1>하노이의 탑 문제 구조!!</h1>




n개의 원판을 from → to로 옮길 때:

1. n-1개의 원판을 from → via로 옮긴다. (큰 원판을 꺼내기 위해)

2. n번째(가장 큰) 원판을 from → to로 옮긴다.

3. via에 있던 n-1개의 원판을 다시 to로 옮긴다.

이 3단계는 n이 무엇이든 동일한 패턴으로 반복됩니다.



'''
// 하노이의 탑

public class HanoiTower {

    public static void hanoi(int n, char from, char to, char aux) {
        // 기저 조건
        if (n == 1) {
            System.out.println("원판 1을 " + from + " → " + to);
            return;
        }
        // 1단계: N-1개를 보조 기둥(aux)로 이동
        hanoi(n - 1, from, aux, to);

        // 2단계: 가장 큰 원판 이동
        System.out.println("원판 " + n + "을 " + from + " → " + to);

        // 3단계: N-1개를 목적지(to)로 이동
        hanoi(n - 1, aux, to, from);
    }

    public static void main(String[] args) {
        int N = 3;
        hanoi(N, 'A', 'C', 'B');
    }
}


'''


쉽게 비유

하노이의 탑: "큰 문제를 둘로 나누어 차례로 해결"

피보나치 수열: "큰 문제를 여러 작은 문제의 결과를 합쳐서 해결"

선택 정렬 재귀: "앞자리 하나 정하고, 남은 부분을 같은 방식으로 해결"


제 논리적 오류는, hanoi 재귀 호출에서 n-1 값을 따로 저장해 두지 않으므로, 호출마다 n-1이 새로 계산되어 전달되며, 이전 호출에서 n이 누적 감소되는 방식으로 동작하지 않는다는 점이었습니다.

수정한 논리 

-> n-1은 이전 호출에서 누적 감소되지 않고, 매 호출마다 현재 n에서 1을 뺀 값을 새로 계산해 전달한다.


<hr>
<h1>추가적으로 생각하며, 정리한 내용 </h1>

```
public class HanoiTower {

    public static void hanoi(int n, char from, char to, char aux) {
        // 기저 조건
        if (n == 1) {
            System.out.println("원판 1을 " + from + " → " + to);
            return;
        }
        // 1단계: N-1개를 보조 기둥(aux)로 이동
        hanoi(n - 1, from, aux, to);

        // 2단계: 가장 큰 원판 이동
        System.out.println("원판 " + n + "을 " + from + " → " + to);

        // 3단계: N-1개를 목적지(to)로 이동
        hanoi(n - 1, aux, to, from);
    }

    public static void main(String[] args) {
        int N = 3;
        hanoi(N, 'A', 'C', 'B');
    }
```

원판 1을 A → C
원판 2을 A → B
원판 1을 C → B
원판 3을 A → C
원판 1을 B → A
원판 2을 B → C
원판 1을 A → C


하노이 함수 호출 구조는 다음과 같습니다.

hanoi(n, from, to, aux)
from → 시작 기둥
to → 목적 기둥
aux → 보조 기둥


정석 알고리즘

n-1개의 원판을 from → aux로 옮김 (to를 보조로 사용) // 코드로 표현 hanoi(n - 1, from, aux, to);

1개의 원판(가장 큰 원판)을 from → to로 옮김  // 코드로 표현 print(from -> to);

n-1개의 원판을 aux → to로 옮김 (from을 보조로 사용) // 코드로 표현 hanoi(n - 1, aux, to, from);


<h1>한 줄로 정리 (약간 다듬음)</h1>

1) n-1개의 원판을 from → aux로 옮긴다.
→ 이는 hanoi(n-1, from, aux, to) 재귀 호출로 표현되고, 이 호출은 **더 작은 문제들로 쪼개져 결국 n==1(한 판 이동)**까지 내려가 하나씩 이동시킨다.
(예시로 미트료시카를 들 수 있음 )

2) 남은 1개
(현재 단계에서의 가장 큰 원판, 즉 원래 전체 중에서는 n번 째 원판)를 from → to로 옮긴다. 
→ 이 동작은 print(from -> to)에 해당한다.

즉, 위의 재귀함수를 통해서 보조기둥에서 크기가 가장 작은 원판이 제일 위에 있는 형태로 쌓여있는 과정이 끝났다는 것을 의미

3) 처음에 aux로 옮겨 놓았던 n-1개의 원판을 aux → to로 옮긴다.
→ 이는 hanoi(n-1, aux, to, from) 호출이고, 다시 작은 문제로 쪼개져 순서대로 이동시킨다.

핵심 포인트 (왜 되는가)
재귀는 쪼갬과 복원(backtracking) 으로 동작합니다. 1번에서 n-1을 보조기둥으로 옮기는 과정이 완전히 끝나야(=재귀가 반환되어야) 2번의 큰 원판 이동이 발생하고, 그때부터 3번이 이어집니다.

그래서 각 단계에서 “큰 원판을 한 번에 옮기려면 아래의 작은 원판들이 보조기둥에 쌓여 있어야 한다”는 제약이 항상 지켜집니다.

잘못된 점검 포인트: 첫 재귀 호출에 to와 aux를 바꿔 넣으면 전체 흐름이 꼬입니다. (이게 흔한 실수)

추가 팁
총 이동 횟수는 2^n - 1입니다.

재귀 트레이스를 직접 그려보면(특히 n=3) 왜 순서가 그렇게 나오는지 눈에 잘 들어옵니다.

