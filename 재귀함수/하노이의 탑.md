<h1>하노이의 탑 문제 구조!!</h1>




n개의 원판을 from → to로 옮길 때:

1. n-1개의 원판을 from → via로 옮긴다. (큰 원판을 꺼내기 위해)

2. n번째(가장 큰) 원판을 from → to로 옮긴다.

3. via에 있던 n-1개의 원판을 다시 to로 옮긴다.

이 3단계는 n이 무엇이든 동일한 패턴으로 반복됩니다.



'''
// 하노이의 탑

public class HanoiTower {

    public static void hanoi(int n, char from, char to, char aux) {
        // 기저 조건
        if (n == 1) {
            System.out.println("원판 1을 " + from + " → " + to);
            return;
        }
        // 1단계: N-1개를 보조 기둥(aux)로 이동
        hanoi(n - 1, from, aux, to);

        // 2단계: 가장 큰 원판 이동
        System.out.println("원판 " + n + "을 " + from + " → " + to);

        // 3단계: N-1개를 목적지(to)로 이동
        hanoi(n - 1, aux, to, from);
    }

    public static void main(String[] args) {
        int N = 3;
        hanoi(N, 'A', 'C', 'B');
    }
}


'''


쉽게 비유

하노이의 탑: "큰 문제를 둘로 나누어 차례로 해결"

피보나치 수열: "큰 문제를 여러 작은 문제의 결과를 합쳐서 해결"

선택 정렬 재귀: "앞자리 하나 정하고, 남은 부분을 같은 방식으로 해결"


제 논리적 오류는, hanoi 재귀 호출에서 n-1 값을 따로 저장해 두지 않으므로, 호출마다 n-1이 새로 계산되어 전달되며, 이전 호출에서 n이 누적 감소되는 방식으로 동작하지 않는다는 점이었습니다.

수정한 논리 

-> n-1은 이전 호출에서 누적 감소되지 않고, 매 호출마다 현재 n에서 1을 뺀 값을 새로 계산해 전달한다.